<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anywhere Clip</title>
    <style>
        :root {
            /* 浅色模式：星星风格 */
            --bg-color: rgba(255, 255, 255, 0.98);
            --text-color: #1F2937;
            --border-color: rgba(0, 0, 0, 0.08);
            --hover-bg: rgba(0, 0, 0, 0.05);
            --accent-color: #3B82F6;
            --success-color: #10B981;
            --error-color: #EF4444;
            --input-color: #8B5CF6;
            /* 拖拽按钮紫色 */
            --shadow: 0 8px 30px rgba(0, 0, 0, 0);

            /* 星星粒子颜色 */
            --p-color-1: #FFD700;
            /* 金黄 */
            --p-color-2: #FFFFFF;
            /* 纯白 */
            --p-color-3: #FDE68A;
            /* 浅黄 */
        }

        html.dark {
            /* 深色模式：灰尘精灵风格 */
            --bg-color: rgba(30, 30, 30, 0.98);
            --text-color: #F3F4F6;
            --border-color: rgba(255, 255, 255, 0.12);
            --hover-bg: rgba(255, 255, 255, 0.15);
            --shadow: 0 8px 30px rgba(0, 0, 0, 0);
            --input-color: #A78BFA;

            /* 灰尘粒子颜色 */
            --p-color-1: #000000;
            --p-color-2: #2d2d2d;
            --p-color-3: #1a1a1a;
        }

        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: transparent;
            font-family: system-ui, -apple-system, sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
        }

        #particle-stage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        /* 主窗口容器 */
        #container {
            width: 300px;
            height: 50px;
            background-color: var(--bg-color);
            border-radius: 50px !important;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow);

            display: flex;
            align-items: center;
            padding: 0 6px;
            box-sizing: border-box;

            position: relative;
            z-index: 10;

            opacity: 1;
            transform: scale(1);
            transition: opacity 0.3s, transform 0.3s;
        }

        /* [修改] 瞬间消失，产生破碎错觉 */
        #container.vanish {
            opacity: 0;
            transition: opacity 0s;
            pointer-events: none;
        }

        /* 通用按钮样式 */
        .control-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s, transform 0.1s;
            color: var(--text-color);
            position: relative;
        }

        .control-btn:hover {
            background-color: var(--hover-bg);
            transform: scale(1.05);
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        /* 左侧区域：关闭 -> 复制 */
        .left-zone {
            width: 38px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        /* 状态A: 关闭 */
        .control-btn.close:hover {
            color: var(--error-color);
            background-color: rgba(239, 68, 68, 0.1);
        }

        /* 状态B: 复制 */
        .control-btn.copy:hover {
            color: var(--success-color);
            background-color: rgba(16, 185, 129, 0.1);
        }

        /* 图标切换动画 */
        .icon-layer {
            position: absolute;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .icon-hidden {
            opacity: 0;
            transform: scale(0.5);
            pointer-events: none;
        }

        .icon-visible {
            opacity: 1;
            transform: scale(1);
        }

        /* 中间内容区 */
        .content-zone {
            flex-grow: 1;
            height: 100%;
            display: flex;
            align-items: center;
            overflow: hidden;
            position: relative;
            padding: 0 2px;
            -webkit-app-region: drag;
        }

        #text-display {
            font-size: 14px;
            color: var(--text-color);
            width: 100%;
            white-space: nowrap;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.2s;
            display: block;
            text-align: left;
        }

        #text-display.visible {
            opacity: 1;
        }

        /* 中央加载动画 */
        #center-loader {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            gap: 5px;
            pointer-events: none;
        }

        .dot {
            width: 6px;
            height: 6px;
            background-color: var(--text-color);
            opacity: 0.6;
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .dot:nth-child(1) {
            animation-delay: -0.32s;
        }

        .dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes bounce {

            0%,
            80%,
            100% {
                transform: scale(0);
            }

            40% {
                transform: scale(1);
            }
        }

        /* 右侧区域：加载圈 -> 输入按钮 */
        .right-zone {
            width: 38px;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .stream-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid rgba(128, 128, 128, 0.2);
            border-left-color: var(--text-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: none;
        }

        @keyframes spin {
            100% {
                transform: rotate(360deg);
            }
        }

        /* 输入按钮 */
        .control-btn.input {
            display: none;
            /* 默认隐藏 */
        }

        .control-btn.input:hover {
            color: var(--input-color);
            background-color: rgba(139, 92, 246, 0.1);
        }

        .control-btn.input.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }

        /* 完成状态下的样式变更 */
        #container.finished {
            animation: golden-flash 0.6s ease-out;
        }

        #container.finished .stream-spinner {
            display: none !important;
        }

        #container.finished .control-btn.input {
            display: flex !important;
        }

        /* ================= 粒子动画核心样式 ================= */
        .particle {
            position: absolute;
            pointer-events: none;
            will-change: transform;
            border-radius: 50%;
            opacity: 1 !important;
            /* 强制全程不透明 */
            filter: none !important;
            /* 强制无模糊 */
            z-index: 20;
        }

        /* 统一使用内爆动画：原地缩小消失，不改变透明度 */
        @keyframes particle-implode {
            0% {
                transform: translate(0, 0) scale(1);
            }

            100% {
                /* 最终状态：位移极小，体积为0，实现“消失” */
                transform: translate(var(--tx), var(--ty)) scale(0);
            }
        }

        /* [修改] 金边闪烁：移除外部光晕，改用内边框 */
        @keyframes golden-flash {
            0% {
                border-color: var(--border-color);
                box-shadow: none;
            }

            30% {
                border-color: #F59E0B;
                /* 金黄色 */
                box-shadow: inset 0 0 0 1px #F59E0B;
                /* 内发光模拟边框加粗 */
            }

            100% {
                border-color: var(--border-color);
                box-shadow: none;
            }
        }
    </style>
</head>

<body>
    <div id="particle-stage"></div>

    <div id="container">
        <!-- 左侧：关闭/复制 (合并) -->
        <div class="left-zone">
            <div id="btn-left" class="control-btn close" title="关闭 (Esc)">
                <!-- 关闭图标 -->
                <svg id="icon-close" class="icon-layer icon-visible" width="16" height="16" viewBox="0 0 24 24"
                    fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
                <!-- 复制图标 -->
                <svg id="icon-copy" class="icon-layer icon-hidden" width="16" height="16" viewBox="0 0 24 24"
                    fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                    <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                </svg>
                <!-- 成功勾选 -->
                <svg id="icon-check" class="icon-layer icon-hidden" width="18" height="18" viewBox="0 0 24 24"
                    fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"
                    style="color: var(--success-color);">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
            </div>
        </div>

        <!-- 中间：内容 -->
        <div class="content-zone">
            <div id="center-loader">
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
            </div>
            <div id="text-display"></div>
        </div>

        <!-- 右侧：流式加载 / 输入 -->
        <div class="right-zone">
            <div id="stream-loader" class="stream-spinner"></div>

            <div id="btn-input" class="control-btn input" draggable="true" title="拖拽到目标窗口输入 / 点击模拟打字">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"
                    stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="4 7 4 4 20 4 20 7"></polyline>
                    <line x1="9" y1="20" x2="15" y2="20"></line>
                    <line x1="12" y1="4" x2="12" y2="20"></line>
                </svg>
            </div>
        </div>
    </div>

    <script>
        const container = document.getElementById('container');
        const particleStage = document.getElementById('particle-stage');
        const centerLoader = document.getElementById('center-loader');
        const textDisplay = document.getElementById('text-display');
        const btnLeft = document.getElementById('btn-left');
        const btnInput = document.getElementById('btn-input');
        const streamLoader = document.getElementById('stream-loader');

        // Icons
        const iconClose = document.getElementById('icon-close');
        const iconCopy = document.getElementById('icon-copy');
        const iconCheck = document.getElementById('icon-check');

        // 数据状态
        let fullTextData = ""; // 后端接收到的完整数据
        let visualText = "";   // 屏幕上当前显示的动画数据

        let isTaskFinished = false;
        let isClosing = false;
        let isTyping = false;
        let isRendering = false; // 是否正在执行动画循环

        let shutdownTimer = null;
        let animationTimer = null;
        let isDarkMode = false;

        // --- 核心：打字机动画循环 ---
        function renderLoop() {
            // 如果显示的文字少于接收到的文字，继续渲染
            if (visualText.length < fullTextData.length) {
                isRendering = true;

                // 确保UI已切换到显示状态
                if (centerLoader.style.display !== 'none') {
                    centerLoader.style.display = 'none';
                    textDisplay.classList.add('visible');
                    streamLoader.style.display = 'block';
                }

                // 动态步长算法：积压越多，跑得越快，保证流畅且不卡顿
                const lag = fullTextData.length - visualText.length;
                const step = Math.max(1, Math.ceil(lag / 5));

                // 追加文本
                visualText += fullTextData.substr(visualText.length, step);

                // 更新 DOM
                textDisplay.textContent = visualText.replace(/[\r\n]+/g, ' ');
                textDisplay.scrollLeft = textDisplay.scrollWidth; // 自动跟随滚动

                requestAnimationFrame(renderLoop);
            } else {
                isRendering = false;
                // 如果任务已完成且动画已播放完毕，确保加载圈隐藏
                if (isTaskFinished) {
                    streamLoader.style.display = 'none';
                }
            }
        }

        if (window.preload && window.preload.receiveMsg) {
            // 1. 初始化配置
            window.preload.receiveMsg((data) => {
                const { config } = data;
                isDarkMode = config.isDarkMode;
                if (isDarkMode) document.documentElement.classList.add('dark');

                // 初始状态：显示中间加载点
                if (centerLoader.style.display !== 'none') {
                    centerLoader.style.display = 'none';
                    textDisplay.classList.add('visible');
                    streamLoader.style.display = 'block';
                }
            });

            // 2. 监听流式数据
            if (window.preload.onStreamUpdate) {
                window.preload.onStreamUpdate((data) => {
                    const { type, payload } = data;

                    if (type === 'chunk') {
                        // 仅累加数据，不直接操作DOM，交给 renderLoop
                        fullTextData += payload;
                        if (!isRendering) renderLoop();
                    }
                    else if (type === 'done') {
                        handleTaskFinish(); // 标记完成
                    }
                    else if (type === 'error') {
                        // 错误情况直接显示，不走动画
                        fullTextData = payload;
                        visualText = fullTextData;
                        handleTaskFinish(true);
                    }
                });
            }
        }

        function handleTaskFinish(isError = false) {
            isTaskFinished = true;

            if (isError) {
                textDisplay.textContent = fullTextData;
                textDisplay.style.color = 'var(--error-color)';
                centerLoader.style.display = 'none';
                streamLoader.style.display = 'none';
            } else {
                // 如果动画已经追平，立即隐藏加载圈；否则 renderLoop 会在追平后隐藏它
                if (!isRendering) {
                    streamLoader.style.display = 'none';
                }
            }

            // 切换 UI 状态 -> 完成 (金边内闪烁)
            container.classList.add('finished');

            // 左侧按钮：从 Close 变为 Copy
            btnLeft.classList.remove('close');
            btnLeft.classList.add('copy');
            btnLeft.title = "复制并关闭";

            iconClose.classList.remove('icon-visible');
            iconClose.classList.add('icon-hidden');
            iconCopy.classList.remove('icon-hidden');
            iconCopy.classList.add('icon-visible');

            // 自动复制完整文本
            window.api.copyText(fullTextData);
            checkShutdownLogic();
        }

        function checkShutdownLogic() {
            if (!isTaskFinished || isClosing || isTyping) return;
            if (!document.hasFocus()) {
                startCountdown();
            }
        }

        function startCountdown() {
            if (shutdownTimer) clearTimeout(shutdownTimer);
            if (isTyping) return;

            console.log("Start 3s countdown...");
            shutdownTimer = setTimeout(() => {
                playCloseAnimation();
            }, 3000);
        }

        function playCloseAnimation() {
            if (isClosing) return;
            isClosing = true;

            spawnParticles();
            container.classList.add('vanish'); // 触发CSS瞬间消失

            animationTimer = setTimeout(() => {
                window.api.closeWindow({ x: window.screenX, y: window.screenY });
            }, 1000);
        }

        function restoreWindow() {
            console.log("Interrupted! Restoring...");
            if (shutdownTimer) clearTimeout(shutdownTimer);
            if (animationTimer) clearTimeout(animationTimer);
            shutdownTimer = null;
            animationTimer = null;
            isClosing = false;

            container.classList.remove('vanish');
            particleStage.innerHTML = '';
        }

        window.addEventListener('blur', () => {
            if (isTaskFinished && !isClosing && !isTyping) {
                startCountdown();
            }
        });

        window.addEventListener('focus', restoreWindow);
        document.addEventListener('mousedown', restoreWindow);

        // 左侧按钮逻辑
        btnLeft.addEventListener('click', (e) => {
            e.stopPropagation();
            if (!isTaskFinished) {
                // 未完成 -> 关闭
                playCloseAnimation();
            } else {
                // 已完成 -> 复制并关闭
                window.api.copyText(fullTextData);

                // 勾选动画
                iconCopy.classList.remove('icon-visible');
                iconCopy.classList.add('icon-hidden');
                iconCheck.classList.remove('icon-hidden');
                iconCheck.classList.add('icon-visible');

                playCloseAnimation();
            }
        });

        // --- 右侧输入按钮逻辑 ---

        // 1. 拖拽开始
        btnInput.addEventListener('dragstart', (e) => {
            e.dataTransfer.setData("text/plain", fullTextData);
            btnInput.classList.add('dragging');
            restoreWindow();
            isTyping = true; // 锁定状态，防止失焦关闭
        });

        // 2. 拖拽结束 -> 立即输入 -> 延时关闭
        btnInput.addEventListener('dragend', (e) => {
            btnInput.classList.remove('dragging');

            // if (window.api.typeText) {
            //     window.api.typeText(fullTextData);
            // }
            setTimeout(() => {
                isTyping = false;
                playCloseAnimation();
            }, 1000);
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') playCloseAnimation();
        });

        // ================= 粒子特效 (最终修正版) =================

        function spawnParticles() {
            const rect = container.getBoundingClientRect();
            // 减少粒子数量，避免过于拥挤导致视觉溢出感
            const particleCount = 150;

            // 【关键】安全内边距：确保粒子生成在圆角矩形内部
            const paddingX = 15;
            const paddingY = 5;

            const spawnW = rect.width - paddingX * 2;
            const spawnH = rect.height - paddingY * 2;

            for (let i = 0; i < particleCount; i++) {
                const p = document.createElement('div');
                p.classList.add('particle');

                // 随机生成坐标（在安全区域内）
                const offsetX = Math.random() * spawnW + paddingX;
                const offsetY = Math.random() * spawnH + paddingY;

                const startX = rect.left + offsetX;
                const startY = rect.top + offsetY;

                p.style.left = startX + 'px';
                p.style.top = startY + 'px';

                // 【关键】极小的位移（抖动），最大仅 2px
                // 确保粒子不会飞出狭窄的窗口可视区域
                const jitter = 2;
                const tx = (Math.random() - 0.5) * jitter * 2;
                const ty = (Math.random() - 0.5) * jitter * 2;

                p.style.setProperty('--tx', tx + 'px');
                p.style.setProperty('--ty', ty + 'px');

                // 统一动画时长，快速消失
                const duration = 0.3 + Math.random() * 0.2;
                // 深色浅色统一使用缩小消失动画
                p.style.animation = `particle-implode ${duration}s ease-out forwards`;

                if (isDarkMode) {
                    // --- 深色模式：煤灰 ---
                    const size = 4 + Math.random() * 4;
                    p.style.width = size + 'px';
                    p.style.height = size + 'px';
                    p.style.borderRadius = '50%';

                    const randC = Math.random();
                    if (randC > 0.6) p.style.backgroundColor = 'var(--p-color-1)';
                    else if (randC > 0.3) p.style.backgroundColor = 'var(--p-color-2)';
                    else p.style.backgroundColor = 'var(--p-color-3)';

                } else {
                    // --- 浅色模式：碎片 ---
                    const size = 5 + Math.random() * 6;
                    p.style.width = size + 'px';
                    p.style.height = size + 'px';

                    if (Math.random() > 0.5) {
                        p.style.borderRadius = '2px'; // 方形碎片
                    } else {
                        p.style.borderRadius = '50%';
                    }

                    const randC = Math.random();
                    if (randC > 0.6) p.style.backgroundColor = 'var(--p-color-1)';
                    else if (randC > 0.2) p.style.backgroundColor = 'var(--p-color-2)';
                    else p.style.backgroundColor = 'var(--p-color-3)';
                }

                particleStage.appendChild(p);
            }
        }
    </script>
</body>

</html>