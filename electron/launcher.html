<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Anywhere Launcher</title>
  <style>
    :root {
      --border: rgba(143, 180, 230, 0.34);
      --border-active: rgba(134, 194, 255, 0.76);
      --text-main: #eff6ff;
      --text-sub: rgba(191, 212, 240, 0.76);
      --card-bg: rgba(13, 20, 31, 0.92);
      --card-hover: rgba(26, 40, 60, 0.94);
      --card-selected: rgba(45, 72, 108, 0.96);
    }

    * {
      box-sizing: border-box;
      user-select: none;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: transparent;
      font-family: "IBM Plex Sans", "Noto Sans SC", "Segoe UI", sans-serif;
      color: var(--text-main);
    }

    body {
      padding: 8px;
    }

    .launcher-shell {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      cursor: default;
    }

    .launcher-shell.dragging,
    .launcher-shell.dragging * {
      cursor: grabbing !important;
    }

    #queryInput {
      width: 100%;
      height: 40px;
      flex: 0 0 40px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: rgba(15, 22, 33, 0.95);
      color: var(--text-main);
      font-size: 16px;
      padding: 0 12px;
      outline: none;
      transition: border-color 0.16s ease, box-shadow 0.16s ease;
      font-family: inherit;
      user-select: text;
      cursor: text;
    }

    #queryInput::placeholder {
      color: rgba(191, 212, 240, 0.56);
    }

    #queryInput:focus {
      border-color: var(--border-active);
      box-shadow: none;
    }

    .result-list {
      display: none;
      margin-top: 8px;
      overflow: auto;
      padding: 4px;
      border-radius: 10px;
      background: rgba(9, 14, 23, 0.7);
      border: 1px solid rgba(116, 152, 202, 0.24);
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 8px;
      align-content: start;
    }

    .result-list.visible {
      display: grid;
    }

    .result-list::-webkit-scrollbar {
      width: 7px;
    }

    .result-list::-webkit-scrollbar-thumb {
      border-radius: 8px;
      background: rgba(127, 168, 224, 0.34);
    }

    .result-empty {
      grid-column: 1 / -1;
      font-size: 13px;
      color: var(--text-sub);
      text-align: center;
      padding: 16px 10px;
      border-radius: 8px;
      background: rgba(13, 20, 31, 0.84);
      border: 1px dashed rgba(116, 152, 202, 0.24);
    }

    .prompt-card {
      appearance: none;
      border: 1px solid rgba(115, 151, 200, 0.24);
      border-radius: 8px;
      background: var(--card-bg);
      color: inherit;
      display: flex;
      align-items: center;
      gap: 10px;
      min-height: 50px;
      padding: 8px 10px;
      cursor: pointer;
      transition: background 0.14s ease, border-color 0.14s ease;
      text-align: left;
      font-family: inherit;
    }

    .prompt-card:hover {
      background: var(--card-hover);
      border-color: rgba(129, 175, 235, 0.42);
    }

    .prompt-card.selected {
      background: var(--card-selected);
      border-color: rgba(149, 197, 255, 0.6);
    }

    .prompt-icon {
      width: 30px;
      height: 30px;
      flex: 0 0 30px;
      border-radius: 7px;
      display: grid;
      place-items: center;
      font-size: 10px;
      font-weight: 700;
      color: #dff0ff;
      background: rgba(43, 61, 84, 0.84);
      border: 1px solid rgba(134, 174, 230, 0.3);
      overflow: hidden;
      user-select: none;
    }

    .prompt-icon img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .prompt-name {
      flex: 1;
      min-width: 0;
      font-size: 13px;
      line-height: 1.35;
      color: #f3f8ff;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  </style>
</head>
<body>
  <main class="launcher-shell" id="launcherShell">
    <input
      id="queryInput"
      type="text"
      autocomplete="off"
      spellcheck="false"
      placeholder="输入文本，或粘贴图片/文件"
    />
    <section class="result-list" id="resultList"></section>
  </main>

  <script>
    (() => {
      const launcherApi = window.launcherApi;
      const shell = document.getElementById('launcherShell');
      const queryInput = document.getElementById('queryInput');
      const resultList = document.getElementById('resultList');
      const layout = {
        baseWindowHeight: 56,
        listGap: 8,
        maxListHeight: 320,
        resizeRaf: 0,
        queuedHeight: 0,
        lastSentHeight: 0,
      };

      const state = {
        prompts: [],
        filtered: [],
        selectedIndex: -1,
        attachment: null,
        showResults: false,
      };

      const drag = {
        pointerId: null,
        pointerDown: false,
        dragging: false,
        startScreenX: 0,
        startScreenY: 0,
        startWindowX: 0,
        startWindowY: 0,
        currentWindowX: 0,
        currentWindowY: 0,
        suppressClickUntil: 0,
        moveRaf: 0,
        queuedMove: null,
      };

      function normalizePromptType(rawType) {
        const value = String(rawType || 'general').toLowerCase();
        if (value === 'text') return 'over';
        if (value === 'image') return 'img';
        if (value === 'file') return 'files';
        return value;
      }

      function parseRegexLiteral(value) {
        if (typeof value !== 'string') return null;
        const trimmed = value.trim();
        if (!trimmed || !trimmed.startsWith('/')) return null;

        const tail = trimmed.lastIndexOf('/');
        if (tail <= 0) return null;

        const body = trimmed.slice(1, tail);
        const flags = trimmed.slice(tail + 1);

        try {
          return new RegExp(body, flags);
        } catch (_error) {
          return null;
        }
      }

      function supportsAttachment(prompt, attachmentKind) {
        if (!attachmentKind) return true;
        const type = normalizePromptType(prompt.type);
        if (attachmentKind === 'img') return type === 'general' || type === 'img';
        if (attachmentKind === 'files') return type === 'general' || type === 'files';
        return true;
      }

      function supportsTextPayload(prompt, textPayload) {
        const type = normalizePromptType(prompt.type);
        if (type !== 'general' && type !== 'over') return false;

        if (type === 'over' && textPayload) {
          const regex = parseRegexLiteral(prompt.matchRegex);
          if (regex) return regex.test(textPayload);
        }

        return true;
      }

      function promptScore(prompt, query) {
        if (!query) return 0;
        const name = String(prompt.code || '').toLowerCase();
        const description = String(prompt.prompt || '').toLowerCase();

        if (name === query) return 1000;
        if (name.startsWith(query)) return 620;
        if (name.includes(query)) return 420;
        if (description.includes(query)) return 120;
        return 0;
      }

      function promptContextPriority(prompt, attachmentKind, textPayload) {
        const type = normalizePromptType(prompt.type);

        if (attachmentKind === 'img') {
          if (type === 'img') return 2;
          if (type === 'general') return 1;
          return 0;
        }

        if (attachmentKind === 'files') {
          if (type === 'files') return 2;
          if (type === 'general') return 1;
          return 0;
        }

        if (textPayload) {
          if (type === 'over') return 2;
          if (type === 'general') return 1;
          return 0;
        }

        return 0;
      }

      function queueWindowResize(height) {
        if (!launcherApi.setWindowSize) return;
        const nextHeight = Math.round(height);
        if (nextHeight === layout.lastSentHeight && !layout.resizeRaf) return;

        layout.queuedHeight = nextHeight;
        if (layout.resizeRaf) return;

        layout.resizeRaf = requestAnimationFrame(() => {
          layout.resizeRaf = 0;
          if (layout.queuedHeight === layout.lastSentHeight) return;
          launcherApi.setWindowSize({ height: layout.queuedHeight });
          layout.lastSentHeight = layout.queuedHeight;
        });
      }

      function syncWindowSize() {
        let nextHeight = layout.baseWindowHeight;

        if (state.showResults) {
          const listHeight = Math.min(resultList.scrollHeight, layout.maxListHeight);
          if (listHeight > 0) {
            nextHeight = layout.baseWindowHeight + layout.listGap + listHeight;
          }
        }

        queueWindowResize(nextHeight);
      }

      function updateInputPlaceholder() {
        if (state.attachment?.kind === 'img') {
          queryInput.placeholder = '已附加图片，选择截图/通用助手';
          return;
        }
        if (state.attachment?.kind === 'files') {
          queryInput.placeholder = '已附加文件，选择文件/通用助手';
          return;
        }
        queryInput.placeholder = '输入文本，或粘贴图片/文件';
      }

      function setAttachment(attachment) {
        state.attachment = attachment;
        updateInputPlaceholder();
        applyFilter();
      }

      function clearAttachment() {
        setAttachment(null);
      }

      function getPromptIconSource(prompt) {
        const icon = typeof prompt.icon === 'string' ? prompt.icon : '';
        if (!icon) return '';
        if (icon.startsWith('data:')) return icon;
        return `data:image/png;base64,${icon}`;
      }

      function renderList() {
        resultList.innerHTML = '';
        resultList.classList.toggle('visible', state.showResults);

        if (!state.showResults) {
          syncWindowSize();
          return;
        }

        if (state.filtered.length === 0) {
          const empty = document.createElement('div');
          empty.className = 'result-empty';
          empty.textContent = '无匹配助手';
          resultList.appendChild(empty);
          syncWindowSize();
          return;
        }

        state.filtered.forEach((prompt, index) => {
          const item = document.createElement('button');
          item.type = 'button';
          item.className = 'prompt-card';
          if (index === state.selectedIndex) item.classList.add('selected');

          const icon = document.createElement('div');
          icon.className = 'prompt-icon';
          const iconSource = getPromptIconSource(prompt);
          if (iconSource) {
            const img = document.createElement('img');
            img.src = iconSource;
            img.alt = '';
            img.onerror = () => {
              icon.textContent = String(prompt.code || '?').slice(0, 2).toUpperCase();
            };
            icon.appendChild(img);
          } else {
            icon.textContent = String(prompt.code || '?').slice(0, 2).toUpperCase();
          }

          const title = document.createElement('div');
          title.className = 'prompt-name';
          title.textContent = prompt.code;

          item.appendChild(icon);
          item.appendChild(title);

          item.addEventListener('mouseenter', () => {
            state.selectedIndex = index;
            renderList();
          });

          item.addEventListener('mousedown', (event) => {
            event.preventDefault();
          });

          item.addEventListener('click', () => {
            state.selectedIndex = index;
            executeCurrent(true);
          });

          resultList.appendChild(item);
        });

        scrollSelectedIntoView();
        syncWindowSize();
      }

      function scrollSelectedIntoView() {
        if (state.selectedIndex < 0) return;
        const selected = resultList.querySelector('.prompt-card.selected');
        if (selected && typeof selected.scrollIntoView === 'function') {
          selected.scrollIntoView({ block: 'nearest' });
        }
      }

      function applyFilter() {
        const queryText = queryInput.value.trim();
        const query = queryText.toLowerCase();
        const attachmentKind = state.attachment ? state.attachment.kind : '';
        const hasSearchContext = queryText.length > 0 || !!attachmentKind;

        state.showResults = hasSearchContext;
        if (!hasSearchContext) {
          state.filtered = [];
          state.selectedIndex = -1;
          renderList();
          return;
        }

        let list = state.prompts.slice();
        if (attachmentKind) {
          list = list.filter((prompt) => supportsAttachment(prompt, attachmentKind));
        } else {
          list = list.filter((prompt) => supportsTextPayload(prompt, queryText));
        }

        list.sort((a, b) => {
          const contextDiff =
            promptContextPriority(b, attachmentKind, queryText) -
            promptContextPriority(a, attachmentKind, queryText);
          if (contextDiff !== 0) return contextDiff;

          const scoreDiff = promptScore(b, query) - promptScore(a, query);
          if (scoreDiff !== 0) return scoreDiff;
          return String(a.code || '').localeCompare(String(b.code || ''));
        });

        state.filtered = list;
        if (state.filtered.length === 0) {
          state.selectedIndex = -1;
        } else if (state.selectedIndex < 0 || state.selectedIndex >= state.filtered.length) {
          state.selectedIndex = 0;
        }

        renderList();
      }

      function buildAction(prompt, useTextPayload) {
        if (state.attachment?.kind === 'img') {
          return { code: prompt.code, type: 'img', payload: state.attachment.dataUrl };
        }
        if (state.attachment?.kind === 'files') {
          return { code: prompt.code, type: 'files', payload: state.attachment.files };
        }

        const query = queryInput.value.trim();
        if (useTextPayload && query) {
          return { code: prompt.code, type: 'over', payload: query };
        }

        return { code: prompt.code, type: 'over', payload: '' };
      }

      function executeCurrent(useTextPayload) {
        if (state.selectedIndex < 0 || state.selectedIndex >= state.filtered.length) return;
        const prompt = state.filtered[state.selectedIndex];
        if (!prompt) return;

        const query = queryInput.value.trim();
        if (state.attachment && !supportsAttachment(prompt, state.attachment.kind)) {
          return;
        }

        let shouldUseTextPayload = useTextPayload;
        if (!state.attachment && shouldUseTextPayload && query && !supportsTextPayload(prompt, query)) {
          shouldUseTextPayload = false;
        }

        launcherApi.execute(buildAction(prompt, shouldUseTextPayload));
      }

      function shiftSelection(step) {
        if (state.filtered.length === 0) return;
        if (state.selectedIndex < 0) state.selectedIndex = 0;
        else state.selectedIndex = (state.selectedIndex + step + state.filtered.length) % state.filtered.length;
        renderList();
      }

      function getGridColumnCount() {
        if (!resultList.classList.contains('visible')) return 1;
        const columns = getComputedStyle(resultList).gridTemplateColumns
          .split(' ')
          .filter(Boolean);
        return Math.max(1, columns.length);
      }

      function queueWindowMove(x, y) {
        drag.queuedMove = { x, y };
        if (drag.moveRaf) return;

        drag.moveRaf = requestAnimationFrame(() => {
          drag.moveRaf = 0;
          if (!drag.queuedMove) return;
          const target = drag.queuedMove;
          drag.queuedMove = null;
          launcherApi.setWindowPosition(target);
          drag.currentWindowX = target.x;
          drag.currentWindowY = target.y;
        });
      }

      async function syncWindowBounds() {
        try {
          const bounds = await launcherApi.getWindowBounds();
          if (!bounds) return;
          drag.currentWindowX = Number(bounds.x) || 0;
          drag.currentWindowY = Number(bounds.y) || 0;
        } catch (_error) {
          // ignore
        }
      }

      function handlePointerDown(event) {
        if (event.button !== 0) return;
        drag.pointerId = event.pointerId;
        drag.pointerDown = true;
        drag.dragging = false;
        drag.startScreenX = event.screenX;
        drag.startScreenY = event.screenY;
        drag.startWindowX = drag.currentWindowX;
        drag.startWindowY = drag.currentWindowY;

        launcherApi.getWindowBounds().then((bounds) => {
          if (!drag.pointerDown || drag.pointerId !== event.pointerId || !bounds) return;
          drag.currentWindowX = Number(bounds.x) || drag.currentWindowX;
          drag.currentWindowY = Number(bounds.y) || drag.currentWindowY;
          drag.startWindowX = drag.currentWindowX;
          drag.startWindowY = drag.currentWindowY;
        }).catch(() => {});
      }

      function handlePointerMove(event) {
        if (!drag.pointerDown || event.pointerId !== drag.pointerId) return;

        const deltaX = event.screenX - drag.startScreenX;
        const deltaY = event.screenY - drag.startScreenY;

        if (!drag.dragging && Math.abs(deltaX) + Math.abs(deltaY) >= 3) {
          drag.dragging = true;
          shell.classList.add('dragging');
        }

        if (!drag.dragging) return;

        queueWindowMove(
          Math.round(drag.startWindowX + deltaX),
          Math.round(drag.startWindowY + deltaY)
        );
      }

      function handlePointerEnd(event) {
        if (!drag.pointerDown || event.pointerId !== drag.pointerId) return;

        if (drag.dragging) {
          drag.suppressClickUntil = Date.now() + 120;
          event.preventDefault();
        }

        drag.pointerDown = false;
        drag.dragging = false;
        shell.classList.remove('dragging');
      }

      function fileToDataUrl(file) {
        return new Promise((resolve) => {
          const reader = new FileReader();
          reader.onload = () => resolve(typeof reader.result === 'string' ? reader.result : '');
          reader.onerror = () => resolve('');
          reader.readAsDataURL(file);
        });
      }

      function isImageFile(file) {
        const type = String(file?.type || '').toLowerCase();
        if (type.startsWith('image/')) return true;

        const name = String(file?.name || '').toLowerCase();
        return /\.(png|jpe?g|webp|gif|bmp|svg)$/.test(name);
      }

      async function consumeFiles(fileList) {
        const files = Array.from(fileList || []);
        if (files.length === 0) return;

        if (files.length === 1 && isImageFile(files[0])) {
          const dataUrl = await fileToDataUrl(files[0]);
          if (dataUrl) {
            setAttachment({
              kind: 'img',
              dataUrl,
              name: files[0].name || 'clipboard-image.png',
            });
            return;
          }
        }

        const filePayload = files
          .map((file) => ({
            name: file.name || 'file',
            path: typeof file.path === 'string' ? file.path : '',
            isFile: true,
          }))
          .filter((file) => !!file.path);

        if (filePayload.length > 0) {
          setAttachment({ kind: 'files', files: filePayload });
        }
      }

      async function refreshPrompts() {
        try {
          const prompts = await launcherApi.getPrompts();
          state.prompts = Array.isArray(prompts) ? prompts : [];
          state.selectedIndex = 0;
          applyFilter();
        } catch (_error) {
          state.prompts = [];
          state.filtered = [];
          state.selectedIndex = -1;
          renderList();
        }
      }

      async function resetAndRefresh() {
        queryInput.value = '';
        clearAttachment();
        await refreshPrompts();
        await syncWindowBounds();
        queryInput.focus();
        queryInput.select();
      }

      queryInput.addEventListener('input', () => {
        applyFilter();
      });

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          event.preventDefault();
          if (state.attachment) {
            clearAttachment();
            return;
          }
          launcherApi.close();
          return;
        }

        if (event.key === 'ArrowDown') {
          event.preventDefault();
          shiftSelection(getGridColumnCount());
          return;
        }

        if (event.key === 'ArrowUp') {
          event.preventDefault();
          shiftSelection(-getGridColumnCount());
          return;
        }

        if (event.key === 'ArrowRight') {
          event.preventDefault();
          shiftSelection(1);
          return;
        }

        if (event.key === 'ArrowLeft') {
          event.preventDefault();
          shiftSelection(-1);
          return;
        }

        if (event.key === 'Enter') {
          event.preventDefault();
          if (!state.showResults) return;
          const useTextPayload = !(event.ctrlKey || event.metaKey);
          executeCurrent(useTextPayload);
        }
      });

      document.addEventListener('pointerdown', handlePointerDown, true);
      document.addEventListener('pointermove', handlePointerMove, true);
      document.addEventListener('pointerup', handlePointerEnd, true);
      document.addEventListener('pointercancel', handlePointerEnd, true);

      document.addEventListener('click', (event) => {
        if (Date.now() < drag.suppressClickUntil) {
          event.preventDefault();
          event.stopPropagation();
        }
      }, true);

      window.addEventListener('drop', async (event) => {
        event.preventDefault();
        await consumeFiles(event.dataTransfer?.files);
      });

      window.addEventListener('dragover', (event) => {
        event.preventDefault();
      });

      window.addEventListener('paste', async (event) => {
        const clipboardFiles = event.clipboardData?.files;
        if (clipboardFiles && clipboardFiles.length > 0) {
          event.preventDefault();
          await consumeFiles(clipboardFiles);
          return;
        }

        const imageData = launcherApi.readClipboardImage();
        if (imageData) {
          event.preventDefault();
          setAttachment({
            kind: 'img',
            dataUrl: imageData,
            name: 'clipboard-image.png',
          });
        }
      });

      launcherApi.onRefresh(() => {
        resetAndRefresh();
      });

      launcherApi.onFocusInput(() => {
        queryInput.focus();
      });

      updateInputPlaceholder();
      resetAndRefresh();
    })();
  </script>
</body>
</html>
