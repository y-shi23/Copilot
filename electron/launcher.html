<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Anywhere Launcher</title>
  <style>
    :root {
      --border: rgba(143, 180, 230, 0.34);
      --border-active: rgba(134, 194, 255, 0.76);
      --text-main: #eff6ff;
      --text-sub: rgba(191, 212, 240, 0.76);
      --card-bg: rgba(13, 20, 31, 0.92);
      --card-hover: rgba(26, 40, 60, 0.94);
      --card-selected: rgba(45, 72, 108, 0.96);
    }

    * {
      box-sizing: border-box;
      user-select: none;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: transparent;
      font-family: "IBM Plex Sans", "Noto Sans SC", "Segoe UI", sans-serif;
      color: var(--text-main);
    }

    .launcher-shell {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      cursor: default;
      background: transparent;
    }

    .launcher-container {
      position: relative;
      width: 100%;
      display: flex;
      flex-direction: column;
      border-radius: 28px;
      border: 1px solid var(--border);
      background: rgba(15, 22, 33, 0.95);
      overflow: hidden;
      transition: border-color 0.16s ease, border-radius 0.15s ease;
    }

    .launcher-container.has-list {
      border-radius: 20px;
    }

    .launcher-shell.dragging,
    .launcher-shell.dragging * {
      cursor: grabbing !important;
    }

    .input-wrap {
      position: relative;
      width: 100%;
      height: 54px;
      min-height: 54px;
      display: flex;
      align-items: center;
      border-radius: 28px;
      transition: border-radius 0.15s ease;
    }

    .launcher-container.has-list .input-wrap {
      border-radius: 20px 20px 0 0;
    }

    .input-icon {
      margin-left: 16px;
      flex-shrink: 0;
      opacity: 0.72;
    }

    #queryInput {
      flex: 1;
      height: 100%;
      border: none;
      background: transparent;
      color: var(--text-main);
      font-size: 22px;
      padding: 0 18px 0 12px;
      outline: none;
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "SF Pro Text", "Segoe UI", sans-serif;
      font-weight: 500;
      letter-spacing: 0.01em;
      user-select: text;
      cursor: text;
    }

    #queryInput::placeholder {
      color: rgba(191, 212, 240, 0.56);
    }

    .attachment-pill {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      height: 26px;
      max-width: 52%;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(26, 40, 60, 0.94);
      color: var(--text-sub);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 0 4px 0 8px;
    }

    .attachment-label {
      font-size: 12px;
      line-height: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 155px;
    }

    .attachment-clear-btn {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: none;
      background: rgba(127, 168, 224, 0.24);
      color: var(--text-sub);
      cursor: pointer;
      display: grid;
      place-items: center;
      padding: 0;
    }

    .attachment-clear-btn:hover {
      background: rgba(127, 168, 224, 0.42);
    }

    .result-list {
      position: relative;
      border-top: 1px solid transparent;
      padding: 0 10px;
      max-height: 0;
      opacity: 0;
      transform: scaleY(0.95) translateY(-4px);
      transform-origin: top center;
      pointer-events: none;
      overflow: hidden;
      will-change: transform, opacity;
      transition:
        transform 160ms cubic-bezier(0.32, 0.72, 0, 1),
        opacity 140ms ease,
        padding 160ms cubic-bezier(0.32, 0.72, 0, 1),
        border-color 160ms ease;
      background: transparent;
    }

    .result-list.visible {
      border-top-color: var(--border);
      padding: 8px 10px 10px;
      max-height: 340px;
      opacity: 1;
      transform: scaleY(1) translateY(0);
      pointer-events: auto;
      overflow: auto;
    }

    .result-list::-webkit-scrollbar {
      width: 7px;
    }

    .result-list::-webkit-scrollbar-thumb {
      border-radius: 8px;
      background: rgba(127, 168, 224, 0.34);
    }

    .result-empty {
      font-size: 12px;
      color: var(--text-sub);
      text-align: center;
      padding: 10px 8px 12px;
      border-radius: 10px;
      background: transparent;
    }

    .launcher-option {
      width: 100%;
      appearance: none;
      border: none;
      border-radius: 11px;
      background: transparent;
      color: inherit;
      display: flex;
      align-items: center;
      gap: 11px;
      min-height: 42px;
      height: 42px;
      padding: 0 10px;
      cursor: pointer;
      text-align: left;
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Segoe UI", sans-serif;
      line-height: 1;
      opacity: 0;
      transform: translateY(6px);
      transition:
        opacity 160ms cubic-bezier(0.32, 0.72, 0, 1),
        transform 180ms cubic-bezier(0.32, 0.72, 0, 1),
        background-color 120ms ease;
      transition-delay: var(--option-delay, 0ms);
    }

    .result-list.visible .launcher-option {
      opacity: 1;
      transform: translateY(0);
    }

    .result-list:not(.visible) .launcher-option {
      transition-delay: 0ms !important;
      transition-duration: 80ms !important;
    }

    .launcher-option:hover {
      background: var(--card-hover);
    }

    .launcher-option.selected {
      background: var(--card-selected);
    }

    .option-icon {
      width: 24px;
      height: 24px;
      min-width: 24px;
      border-radius: 7px;
      display: grid;
      place-items: center;
      font-size: 11px;
      font-weight: 650;
      color: var(--text-sub);
      background: transparent;
      overflow: hidden;
    }

    .option-icon img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .option-name {
      flex: 1;
      min-width: 0;
      font-size: 15px;
      line-height: 1.25;
      color: var(--text-main);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      letter-spacing: 0.01em;
    }

    .option-arrow {
      color: var(--text-sub);
      opacity: 0.7;
    }

    .launcher-option.selected .option-arrow {
      opacity: 0.96;
    }
  </style>
</head>
<body>
  <main class="launcher-shell" id="launcherShell">
    <div class="launcher-container" id="launcherContainer">
      <div class="input-wrap" id="inputWrap">
        <svg class="input-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.3-4.3"></path>
        </svg>
        <input
          id="queryInput"
          type="text"
          autocomplete="off"
          spellcheck="false"
          placeholder="输入文本，或粘贴图片/文件"
        />
        <div class="attachment-pill" id="attachmentPill" style="display: none;">
          <svg id="attachmentIcon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg>
          <span class="attachment-label" id="attachmentLabel"></span>
          <button type="button" class="attachment-clear-btn" id="attachmentClearBtn">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M18 6 6 18"></path>
              <path d="m6 6 12 12"></path>
            </svg>
          </button>
        </div>
      </div>
      <section class="result-list" id="resultList"></section>
    </div>
  </main>

  <script>
    (() => {
      const launcherApi = window.launcherApi;
      const shell = document.getElementById('launcherShell');
      const container = document.getElementById('launcherContainer');
      const queryInput = document.getElementById('queryInput');
      const resultList = document.getElementById('resultList');
      const attachmentPill = document.getElementById('attachmentPill');
      const attachmentIcon = document.getElementById('attachmentIcon');
      const attachmentLabel = document.getElementById('attachmentLabel');
      const attachmentClearBtn = document.getElementById('attachmentClearBtn');

      const layout = {
        baseWindowHeight: 56,
        listGap: 0,
        maxListHeight: 340,
        resizeRaf: 0,
        queuedHeight: 0,
        lastSentHeight: 0,
        listActualHeight: 0,
      };

      const state = {
        prompts: [],
        filtered: [],
        selectedIndex: -1,
        attachment: null,
        showResults: false,
        listMounted: false,
        listVisible: false,
        hideListTimer: 0,
      };

      const drag = {
        pointerId: null,
        pointerDown: false,
        dragging: false,
        startScreenX: 0,
        startScreenY: 0,
        startWindowX: 0,
        startWindowY: 0,
        currentWindowX: 0,
        currentWindowY: 0,
        suppressClickUntil: 0,
        moveRaf: 0,
        queuedMove: null,
      };

      function normalizePromptType(rawType) {
        const value = String(rawType || 'general').toLowerCase();
        if (value === 'text') return 'over';
        if (value === 'image') return 'img';
        if (value === 'file') return 'files';
        return value;
      }

      function parseRegexLiteral(value) {
        if (typeof value !== 'string') return null;
        const trimmed = value.trim();
        if (!trimmed || !trimmed.startsWith('/')) return null;

        const tail = trimmed.lastIndexOf('/');
        if (tail <= 0) return null;

        const body = trimmed.slice(1, tail);
        const flags = trimmed.slice(tail + 1);

        try {
          return new RegExp(body, flags);
        } catch (_error) {
          return null;
        }
      }

      function supportsAttachment(prompt, attachmentKind) {
        if (!attachmentKind) return true;
        const type = normalizePromptType(prompt.type);
        if (attachmentKind === 'img') return type === 'general' || type === 'img';
        if (attachmentKind === 'files') return type === 'general' || type === 'files';
        return true;
      }

      function supportsTextPayload(prompt, textPayload) {
        const type = normalizePromptType(prompt.type);
        if (type !== 'general' && type !== 'over') return false;

        if (type === 'over' && textPayload) {
          const regex = parseRegexLiteral(prompt.matchRegex);
          if (regex) return regex.test(textPayload);
        }

        return true;
      }

      function promptScore(prompt, query) {
        if (!query) return 0;
        const name = String(prompt.code || '').toLowerCase();
        const description = String(prompt.prompt || '').toLowerCase();

        if (name === query) return 1000;
        if (name.startsWith(query)) return 620;
        if (name.includes(query)) return 420;
        if (description.includes(query)) return 120;
        return 0;
      }

      function promptContextPriority(prompt, attachmentKind, textPayload) {
        const type = normalizePromptType(prompt.type);

        if (attachmentKind === 'img') {
          if (type === 'img') return 2;
          if (type === 'general') return 1;
          return 0;
        }

        if (attachmentKind === 'files') {
          if (type === 'files') return 2;
          if (type === 'general') return 1;
          return 0;
        }

        if (textPayload) {
          if (type === 'over') return 2;
          if (type === 'general') return 1;
          return 0;
        }

        return 0;
      }

      function queueWindowResize(height) {
        if (!launcherApi.setWindowSize) return;
        const nextHeight = Math.round(height);
        if (nextHeight === layout.lastSentHeight && !layout.resizeRaf) return;

        layout.queuedHeight = nextHeight;
        if (layout.resizeRaf) return;

        layout.resizeRaf = requestAnimationFrame(() => {
          layout.resizeRaf = 0;
          if (layout.queuedHeight === layout.lastSentHeight) return;
          launcherApi.setWindowSize({ height: layout.queuedHeight });
          layout.lastSentHeight = layout.queuedHeight;
        });
      }

      function syncWindowSize() {
        let nextHeight = layout.baseWindowHeight;

        if (state.listMounted && state.listVisible) {
          const listHeight = Math.min(resultList.scrollHeight, layout.maxListHeight);
          if (listHeight > 0) {
            layout.listActualHeight = listHeight;
            nextHeight = layout.baseWindowHeight + layout.listGap + listHeight;
          }
        } else if (state.listMounted && layout.listActualHeight > 0) {
          nextHeight = layout.baseWindowHeight + layout.listGap + layout.listActualHeight;
        }

        queueWindowResize(nextHeight);
      }

      function updateInputPlaceholder() {
        if (state.attachment?.kind === 'img') {
          queryInput.placeholder = '已附加图片，选择截图/通用助手';
          return;
        }
        if (state.attachment?.kind === 'files') {
          queryInput.placeholder = '已附加文件，选择文件/通用助手';
          return;
        }
        queryInput.placeholder = '输入文本，或粘贴图片/文件';
      }

      function updateAttachmentPill() {
        if (!state.attachment) {
          attachmentPill.style.display = 'none';
          return;
        }

        attachmentPill.style.display = 'inline-flex';
        if (state.attachment.kind === 'img') {
          attachmentIcon.innerHTML = '<rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/>';
          attachmentLabel.textContent = state.attachment.name || 'clipboard-image.png';
        } else {
          attachmentIcon.innerHTML = '<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/>';
          const fileCount = Array.isArray(state.attachment.files) ? state.attachment.files.length : 0;
          attachmentLabel.textContent = fileCount > 0 ? `${fileCount} file${fileCount > 1 ? 's' : ''}` : '0 files';
        }
      }

      function setAttachment(attachment) {
        state.attachment = attachment;
        updateInputPlaceholder();
        updateAttachmentPill();
        applyFilter();
      }

      function clearAttachment() {
        setAttachment(null);
      }

      function getPromptIconSource(prompt) {
        const icon = typeof prompt.icon === 'string' ? prompt.icon : '';
        if (!icon) return '';
        if (icon.startsWith('data:')) return icon;
        return `data:image/png;base64,${icon}`;
      }

      function renderList() {
        resultList.innerHTML = '';

        if (state.hideListTimer) {
          clearTimeout(state.hideListTimer);
          state.hideListTimer = 0;
        }

        const hasResults = state.showResults && state.filtered.length > 0;

        if (hasResults) {
          state.listMounted = true;
          container.classList.add('has-list');
          requestAnimationFrame(() => {
            state.listVisible = true;
            resultList.classList.add('visible');
            syncWindowSize();
          });
        } else {
          state.listVisible = false;
          resultList.classList.remove('visible');
          container.classList.remove('has-list');
          state.hideListTimer = setTimeout(() => {
            state.hideListTimer = 0;
            if (state.showResults && state.filtered.length > 0) return;
            state.listMounted = false;
            layout.listActualHeight = 0;
            syncWindowSize();
          }, 160);
        }

        if (!state.showResults) {
          syncWindowSize();
          return;
        }

        if (state.filtered.length === 0) {
          const empty = document.createElement('div');
          empty.className = 'result-empty';
          empty.textContent = '无匹配助手';
          resultList.appendChild(empty);
          syncWindowSize();
          return;
        }

        state.filtered.forEach((prompt, index) => {
          const item = document.createElement('button');
          item.type = 'button';
          item.className = 'launcher-option';
          if (index === state.selectedIndex) item.classList.add('selected');
          item.style.setProperty('--option-delay', `${Math.min(index * 12, 96)}ms`);

          const icon = document.createElement('div');
          icon.className = 'option-icon';
          const iconSource = getPromptIconSource(prompt);
          if (iconSource) {
            const img = document.createElement('img');
            img.src = iconSource;
            img.alt = '';
            img.onerror = () => {
              icon.textContent = String(prompt.code || '?').slice(0, 2).toUpperCase();
            };
            icon.appendChild(img);
          } else {
            icon.textContent = String(prompt.code || '?').slice(0, 2).toUpperCase();
          }

          const title = document.createElement('div');
          title.className = 'option-name';
          title.textContent = prompt.code;

          const arrow = document.createElement('div');
          arrow.className = 'option-arrow';
          arrow.innerHTML = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>';

          item.appendChild(icon);
          item.appendChild(title);
          item.appendChild(arrow);

          item.addEventListener('mouseenter', () => {
            state.selectedIndex = index;
            renderList();
          });

          item.addEventListener('mousedown', (event) => {
            event.preventDefault();
          });

          item.addEventListener('click', () => {
            state.selectedIndex = index;
            executeCurrent(true);
          });

          resultList.appendChild(item);
        });

        scrollSelectedIntoView();
        syncWindowSize();
      }

      function scrollSelectedIntoView() {
        if (state.selectedIndex < 0) return;
        const selected = resultList.querySelector('.launcher-option.selected');
        if (selected && typeof selected.scrollIntoView === 'function') {
          selected.scrollIntoView({ block: 'nearest' });
        }
      }

      function applyFilter() {
        const queryText = queryInput.value.trim();
        const query = queryText.toLowerCase();
        const attachmentKind = state.attachment ? state.attachment.kind : '';
        const hasSearchContext = queryText.length > 0 || !!attachmentKind;

        state.showResults = hasSearchContext;
        if (!hasSearchContext) {
          state.filtered = [];
          state.selectedIndex = -1;
          renderList();
          return;
        }

        let list = state.prompts.slice();
        if (attachmentKind) {
          list = list.filter((prompt) => supportsAttachment(prompt, attachmentKind));
        } else {
          list = list.filter((prompt) => supportsTextPayload(prompt, queryText));
        }

        list.sort((a, b) => {
          const contextDiff =
            promptContextPriority(b, attachmentKind, queryText) -
            promptContextPriority(a, attachmentKind, queryText);
          if (contextDiff !== 0) return contextDiff;

          const scoreDiff = promptScore(b, query) - promptScore(a, query);
          if (scoreDiff !== 0) return scoreDiff;
          return String(a.code || '').localeCompare(String(b.code || ''));
        });

        state.filtered = list;
        if (state.filtered.length === 0) {
          state.selectedIndex = -1;
        } else if (state.selectedIndex < 0 || state.selectedIndex >= state.filtered.length) {
          state.selectedIndex = 0;
        }

        renderList();
      }

      function buildAction(prompt, useTextPayload) {
        if (state.attachment?.kind === 'img') {
          return { code: prompt.code, type: 'img', payload: state.attachment.dataUrl };
        }
        if (state.attachment?.kind === 'files') {
          return { code: prompt.code, type: 'files', payload: state.attachment.files };
        }

        const query = queryInput.value.trim();
        if (useTextPayload && query) {
          return { code: prompt.code, type: 'over', payload: query };
        }

        return { code: prompt.code, type: 'over', payload: '' };
      }

      function executeCurrent(useTextPayload) {
        if (state.selectedIndex < 0 || state.selectedIndex >= state.filtered.length) return;
        const prompt = state.filtered[state.selectedIndex];
        if (!prompt) return;

        const query = queryInput.value.trim();
        if (state.attachment && !supportsAttachment(prompt, state.attachment.kind)) {
          return;
        }

        let shouldUseTextPayload = useTextPayload;
        if (!state.attachment && shouldUseTextPayload && query && !supportsTextPayload(prompt, query)) {
          shouldUseTextPayload = false;
        }

        launcherApi.execute(buildAction(prompt, shouldUseTextPayload));
      }

      function shiftSelection(step) {
        if (state.filtered.length === 0) return;
        if (state.selectedIndex < 0) state.selectedIndex = 0;
        else state.selectedIndex = (state.selectedIndex + step + state.filtered.length) % state.filtered.length;
        renderList();
      }

      function queueWindowMove(x, y) {
        drag.queuedMove = { x, y };
        if (drag.moveRaf) return;

        drag.moveRaf = requestAnimationFrame(() => {
          drag.moveRaf = 0;
          if (!drag.queuedMove) return;
          const target = drag.queuedMove;
          drag.queuedMove = null;
          launcherApi.setWindowPosition(target);
          drag.currentWindowX = target.x;
          drag.currentWindowY = target.y;
        });
      }

      async function syncWindowBounds() {
        try {
          const bounds = await launcherApi.getWindowBounds();
          if (!bounds) return;
          drag.currentWindowX = Number(bounds.x) || 0;
          drag.currentWindowY = Number(bounds.y) || 0;
        } catch (_error) {
          // ignore
        }
      }

      function handlePointerDown(event) {
        if (event.button !== 0) return;
        drag.pointerId = event.pointerId;
        drag.pointerDown = true;
        drag.dragging = false;
        drag.startScreenX = event.screenX;
        drag.startScreenY = event.screenY;
        drag.startWindowX = drag.currentWindowX;
        drag.startWindowY = drag.currentWindowY;

        launcherApi.getWindowBounds().then((bounds) => {
          if (!drag.pointerDown || drag.pointerId !== event.pointerId || !bounds) return;
          drag.currentWindowX = Number(bounds.x) || drag.currentWindowX;
          drag.currentWindowY = Number(bounds.y) || drag.currentWindowY;
          drag.startWindowX = drag.currentWindowX;
          drag.startWindowY = drag.currentWindowY;
        }).catch(() => {});
      }

      function handlePointerMove(event) {
        if (!drag.pointerDown || event.pointerId !== drag.pointerId) return;

        const deltaX = event.screenX - drag.startScreenX;
        const deltaY = event.screenY - drag.startScreenY;

        if (!drag.dragging && Math.abs(deltaX) + Math.abs(deltaY) >= 3) {
          drag.dragging = true;
          shell.classList.add('dragging');
        }

        if (!drag.dragging) return;

        queueWindowMove(
          Math.round(drag.startWindowX + deltaX),
          Math.round(drag.startWindowY + deltaY)
        );
      }

      function handlePointerEnd(event) {
        if (!drag.pointerDown || event.pointerId !== drag.pointerId) return;

        if (drag.dragging) {
          drag.suppressClickUntil = Date.now() + 120;
          event.preventDefault();
        }

        drag.pointerDown = false;
        drag.dragging = false;
        shell.classList.remove('dragging');
      }

      function fileToDataUrl(file) {
        return new Promise((resolve) => {
          const reader = new FileReader();
          reader.onload = () => resolve(typeof reader.result === 'string' ? reader.result : '');
          reader.onerror = () => resolve('');
          reader.readAsDataURL(file);
        });
      }

      function isImageFile(file) {
        const type = String(file?.type || '').toLowerCase();
        if (type.startsWith('image/')) return true;

        const name = String(file?.name || '').toLowerCase();
        return /\.(png|jpe?g|webp|gif|bmp|svg)$/.test(name);
      }

      async function consumeFiles(fileList) {
        const files = Array.from(fileList || []);
        if (files.length === 0) return;

        if (files.length === 1 && isImageFile(files[0])) {
          const dataUrl = await fileToDataUrl(files[0]);
          if (dataUrl) {
            setAttachment({
              kind: 'img',
              dataUrl,
              name: files[0].name || 'clipboard-image.png',
            });
            return;
          }
        }

        const filePayload = files
          .map((file) => ({
            name: file.name || 'file',
            path: typeof file.path === 'string' ? file.path : '',
            isFile: true,
          }))
          .filter((file) => !!file.path);

        if (filePayload.length > 0) {
          setAttachment({ kind: 'files', files: filePayload });
        }
      }

      async function refreshPrompts() {
        try {
          const prompts = await launcherApi.getPrompts();
          state.prompts = Array.isArray(prompts) ? prompts : [];
          state.selectedIndex = 0;
          applyFilter();
        } catch (_error) {
          state.prompts = [];
          state.filtered = [];
          state.selectedIndex = -1;
          renderList();
        }
      }

      async function resetAndRefresh() {
        queryInput.value = '';
        clearAttachment();
        await refreshPrompts();
        await syncWindowBounds();
        queryInput.focus();
        queryInput.select();
      }

      queryInput.addEventListener('input', () => {
        applyFilter();
      });

      attachmentClearBtn.addEventListener('click', () => {
        clearAttachment();
      });

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          event.preventDefault();
          if (state.attachment) {
            clearAttachment();
            return;
          }
          launcherApi.close();
          return;
        }

        if (event.key === 'ArrowDown') {
          event.preventDefault();
          shiftSelection(1);
          return;
        }

        if (event.key === 'ArrowUp') {
          event.preventDefault();
          shiftSelection(-1);
          return;
        }

        if (event.key === 'Enter') {
          event.preventDefault();
          if (!state.showResults) return;
          const useTextPayload = !(event.ctrlKey || event.metaKey);
          executeCurrent(useTextPayload);
        }
      });

      document.addEventListener('pointerdown', handlePointerDown, true);
      document.addEventListener('pointermove', handlePointerMove, true);
      document.addEventListener('pointerup', handlePointerEnd, true);
      document.addEventListener('pointercancel', handlePointerEnd, true);

      document.addEventListener('click', (event) => {
        if (Date.now() < drag.suppressClickUntil) {
          event.preventDefault();
          event.stopPropagation();
        }
      }, true);

      window.addEventListener('drop', async (event) => {
        event.preventDefault();
        await consumeFiles(event.dataTransfer?.files);
      });

      window.addEventListener('dragover', (event) => {
        event.preventDefault();
      });

      window.addEventListener('paste', async (event) => {
        const clipboardFiles = event.clipboardData?.files;
        if (clipboardFiles && clipboardFiles.length > 0) {
          event.preventDefault();
          await consumeFiles(clipboardFiles);
          return;
        }

        const imageData = launcherApi.readClipboardImage();
        if (imageData) {
          event.preventDefault();
          setAttachment({
            kind: 'img',
            dataUrl: imageData,
            name: 'clipboard-image.png',
          });
        }
      });

      launcherApi.onRefresh(() => {
        resetAndRefresh();
      });

      launcherApi.onFocusInput(() => {
        queryInput.focus();
      });

      updateInputPlaceholder();
      resetAndRefresh();
    })();
  </script>
</body>
</html>
