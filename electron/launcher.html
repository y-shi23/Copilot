<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Anywhere Launcher</title>
  <style>
    :root {
      --bg-main: #0f131b;
      --border: rgba(136, 169, 217, 0.3);
      --border-active: rgba(134, 194, 255, 0.76);
      --text-main: #eff6ff;
      --text-sub: rgba(202, 220, 244, 0.82);
      --item-hover: rgba(58, 85, 122, 0.42);
      --item-active: rgba(82, 120, 170, 0.55);
    }

    * {
      box-sizing: border-box;
      user-select: none;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: transparent;
      font-family: "IBM Plex Sans", "Noto Sans SC", "Segoe UI", sans-serif;
      color: var(--text-main);
    }

    body {
      padding: 12px;
    }

    .launcher-shell {
      width: 100%;
      height: 100%;
      border-radius: 16px;
      border: 1px solid var(--border);
      background:
        radial-gradient(circle at 92% 8%, rgba(127, 189, 255, 0.13), transparent 40%),
        radial-gradient(circle at 10% 98%, rgba(112, 229, 210, 0.1), transparent 46%),
        linear-gradient(164deg, #0d1118 0%, #141c27 62%, #0e1420 100%);
      box-shadow:
        0 22px 60px rgba(2, 5, 8, 0.45),
        0 10px 22px rgba(2, 5, 8, 0.5);
      padding: 14px;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: 10px;
      overflow: hidden;
      cursor: grab;
    }

    .launcher-shell.dragging {
      cursor: grabbing;
    }

    .input-shell {
      width: 100%;
    }

    #queryInput {
      width: 100%;
      border: 1px solid rgba(143, 180, 230, 0.34);
      border-radius: 12px;
      background: rgba(15, 22, 33, 0.9);
      color: var(--text-main);
      font-size: 17px;
      padding: 12px 14px;
      outline: none;
      transition: border-color 0.16s ease, box-shadow 0.16s ease;
      font-family: inherit;
      user-select: text;
      cursor: text;
    }

    #queryInput::placeholder {
      color: rgba(191, 212, 240, 0.56);
    }

    #queryInput:focus {
      border-color: var(--border-active);
      box-shadow: 0 0 0 3px rgba(129, 192, 255, 0.18);
    }

    .result-list {
      margin: 0;
      padding: 0;
      list-style: none;
      overflow: auto;
      border-radius: 12px;
      border: 1px solid rgba(132, 170, 224, 0.2);
      background: rgba(11, 16, 24, 0.5);
      display: none;
    }

    .result-list.visible {
      display: block;
    }

    .result-list::-webkit-scrollbar {
      width: 7px;
    }

    .result-list::-webkit-scrollbar-thumb {
      border-radius: 8px;
      background: rgba(127, 168, 224, 0.34);
    }

    .prompt-item {
      display: grid;
      grid-template-columns: auto 1fr;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(120, 157, 209, 0.12);
      cursor: pointer;
      transition: background 0.14s ease;
    }

    .prompt-item:last-child {
      border-bottom: none;
    }

    .prompt-item:hover {
      background: var(--item-hover);
    }

    .prompt-item.selected {
      background: var(--item-active);
    }

    .prompt-icon {
      width: 28px;
      height: 28px;
      border-radius: 8px;
      display: grid;
      place-items: center;
      font-size: 11px;
      font-weight: 700;
      color: #dff0ff;
      background: rgba(43, 61, 84, 0.84);
      border: 1px solid rgba(134, 174, 230, 0.3);
      overflow: hidden;
      user-select: none;
    }

    .prompt-icon img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .prompt-title {
      font-size: 15px;
      color: #f3f8ff;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  </style>
</head>
<body>
  <main class="launcher-shell" id="launcherShell">
    <div class="input-shell">
      <input
        id="queryInput"
        type="text"
        autocomplete="off"
        spellcheck="false"
        placeholder="输入关键词"
      />
    </div>
    <ul class="result-list" id="resultList"></ul>
  </main>

  <script>
    (() => {
      const launcherApi = window.launcherApi;
      const shell = document.getElementById('launcherShell');
      const queryInput = document.getElementById('queryInput');
      const resultList = document.getElementById('resultList');

      const state = {
        prompts: [],
        filtered: [],
        selectedIndex: -1,
        attachment: null,
        showResults: false,
      };

      const drag = {
        pointerId: null,
        pointerDown: false,
        dragging: false,
        startScreenX: 0,
        startScreenY: 0,
        startWindowX: 0,
        startWindowY: 0,
        currentWindowX: 0,
        currentWindowY: 0,
        suppressClickUntil: 0,
        moveRaf: 0,
        queuedMove: null,
      };

      function normalizePromptType(rawType) {
        const value = String(rawType || 'general').toLowerCase();
        if (value === 'text') return 'over';
        if (value === 'image') return 'img';
        if (value === 'file') return 'files';
        return value;
      }

      function parseRegexLiteral(value) {
        if (typeof value !== 'string') return null;
        const trimmed = value.trim();
        if (!trimmed || !trimmed.startsWith('/')) return null;

        const tail = trimmed.lastIndexOf('/');
        if (tail <= 0) return null;

        const body = trimmed.slice(1, tail);
        const flags = trimmed.slice(tail + 1);

        try {
          return new RegExp(body, flags);
        } catch (_error) {
          return null;
        }
      }

      function supportsAttachment(prompt, attachmentKind) {
        if (!attachmentKind) return true;
        const type = normalizePromptType(prompt.type);
        if (attachmentKind === 'img') return type === 'general' || type === 'img';
        if (attachmentKind === 'files') return type === 'general' || type === 'files';
        return true;
      }

      function supportsTextPayload(prompt, textPayload) {
        const type = normalizePromptType(prompt.type);
        if (type !== 'general' && type !== 'over') return false;

        if (type === 'over' && textPayload) {
          const regex = parseRegexLiteral(prompt.matchRegex);
          if (regex) return regex.test(textPayload);
        }

        return true;
      }

      function promptScore(prompt, query) {
        if (!query) return 0;
        const name = String(prompt.code || '').toLowerCase();
        const description = String(prompt.prompt || '').toLowerCase();

        if (name === query) return 1000;
        if (name.startsWith(query)) return 620;
        if (name.includes(query)) return 420;
        if (description.includes(query)) return 120;
        return 0;
      }

      function updateInputPlaceholder() {
        if (state.attachment?.kind === 'img') {
          queryInput.placeholder = '已附加图片，输入关键词';
          return;
        }
        if (state.attachment?.kind === 'files') {
          queryInput.placeholder = '已附加文件，输入关键词';
          return;
        }
        queryInput.placeholder = '输入关键词';
      }

      function setAttachment(attachment) {
        state.attachment = attachment;
        updateInputPlaceholder();
        applyFilter();
      }

      function clearAttachment() {
        setAttachment(null);
      }

      function renderList() {
        const shouldShowList = state.showResults && state.filtered.length > 0;
        resultList.classList.toggle('visible', shouldShowList);
        resultList.innerHTML = '';

        if (!shouldShowList) return;

        state.filtered.forEach((prompt, index) => {
          const item = document.createElement('li');
          item.className = 'prompt-item';
          if (index === state.selectedIndex) item.classList.add('selected');

          const icon = document.createElement('div');
          icon.className = 'prompt-icon';
          if (prompt.icon) {
            const img = document.createElement('img');
            img.src = prompt.icon.startsWith('data:') ? prompt.icon : `data:image/png;base64,${prompt.icon}`;
            img.alt = '';
            img.onerror = () => {
              icon.textContent = String(prompt.code || '?').slice(0, 2).toUpperCase();
            };
            icon.appendChild(img);
          } else {
            icon.textContent = String(prompt.code || '?').slice(0, 2).toUpperCase();
          }

          const title = document.createElement('div');
          title.className = 'prompt-title';
          title.textContent = prompt.code;

          item.appendChild(icon);
          item.appendChild(title);

          item.addEventListener('mouseenter', () => {
            state.selectedIndex = index;
            renderList();
          });

          item.addEventListener('mousedown', (event) => {
            event.preventDefault();
          });

          item.addEventListener('click', () => {
            executeCurrent(true);
          });

          resultList.appendChild(item);
        });

        scrollSelectedIntoView();
      }

      function scrollSelectedIntoView() {
        if (state.selectedIndex < 0) return;
        const selected = resultList.querySelector('.prompt-item.selected');
        if (selected && typeof selected.scrollIntoView === 'function') {
          selected.scrollIntoView({ block: 'nearest' });
        }
      }

      function applyFilter() {
        const query = queryInput.value.trim().toLowerCase();
        const attachmentKind = state.attachment ? state.attachment.kind : '';
        const hasSearchContext = query.length > 0 || !!attachmentKind;

        state.showResults = hasSearchContext;
        if (!hasSearchContext) {
          state.filtered = [];
          state.selectedIndex = -1;
          renderList();
          return;
        }

        let list = state.prompts.slice();
        if (attachmentKind) {
          list = list.filter((prompt) => supportsAttachment(prompt, attachmentKind));
        }

        if (query) {
          list = list.filter((prompt) => {
            const code = String(prompt.code || '').toLowerCase();
            const promptText = String(prompt.prompt || '').toLowerCase();
            return code.includes(query) || promptText.includes(query);
          });
        }

        list.sort((a, b) => {
          const scoreDiff = promptScore(b, query) - promptScore(a, query);
          if (scoreDiff !== 0) return scoreDiff;
          return String(a.code || '').localeCompare(String(b.code || ''));
        });

        state.filtered = list;
        if (state.filtered.length === 0) {
          state.selectedIndex = -1;
        } else if (state.selectedIndex < 0 || state.selectedIndex >= state.filtered.length) {
          state.selectedIndex = 0;
        }

        renderList();
      }

      function buildAction(prompt, useTextPayload) {
        if (state.attachment?.kind === 'img') {
          return { code: prompt.code, type: 'img', payload: state.attachment.dataUrl };
        }
        if (state.attachment?.kind === 'files') {
          return { code: prompt.code, type: 'files', payload: state.attachment.files };
        }

        const query = queryInput.value.trim();
        if (useTextPayload && query) {
          return { code: prompt.code, type: 'over', payload: query };
        }

        return { code: prompt.code, type: 'over', payload: '' };
      }

      function executeCurrent(useTextPayload) {
        if (state.selectedIndex < 0 || state.selectedIndex >= state.filtered.length) return;
        const prompt = state.filtered[state.selectedIndex];
        if (!prompt) return;

        const query = queryInput.value.trim();
        if (state.attachment && !supportsAttachment(prompt, state.attachment.kind)) {
          return;
        }

        let shouldUseTextPayload = useTextPayload;
        if (!state.attachment && shouldUseTextPayload && query && !supportsTextPayload(prompt, query)) {
          shouldUseTextPayload = false;
        }

        launcherApi.execute(buildAction(prompt, shouldUseTextPayload));
      }

      function shiftSelection(step) {
        if (state.filtered.length === 0) return;
        if (state.selectedIndex < 0) state.selectedIndex = 0;
        else state.selectedIndex = (state.selectedIndex + step + state.filtered.length) % state.filtered.length;
        renderList();
      }

      function queueWindowMove(x, y) {
        drag.queuedMove = { x, y };
        if (drag.moveRaf) return;

        drag.moveRaf = requestAnimationFrame(() => {
          drag.moveRaf = 0;
          if (!drag.queuedMove) return;
          const target = drag.queuedMove;
          drag.queuedMove = null;
          launcherApi.setWindowPosition(target);
          drag.currentWindowX = target.x;
          drag.currentWindowY = target.y;
        });
      }

      async function syncWindowBounds() {
        try {
          const bounds = await launcherApi.getWindowBounds();
          if (!bounds) return;
          drag.currentWindowX = Number(bounds.x) || 0;
          drag.currentWindowY = Number(bounds.y) || 0;
        } catch (_error) {
          // ignore
        }
      }

      function handlePointerDown(event) {
        if (event.button !== 0) return;
        drag.pointerId = event.pointerId;
        drag.pointerDown = true;
        drag.dragging = false;
        drag.startScreenX = event.screenX;
        drag.startScreenY = event.screenY;
        drag.startWindowX = drag.currentWindowX;
        drag.startWindowY = drag.currentWindowY;

        launcherApi.getWindowBounds().then((bounds) => {
          if (!drag.pointerDown || drag.pointerId !== event.pointerId || !bounds) return;
          drag.currentWindowX = Number(bounds.x) || drag.currentWindowX;
          drag.currentWindowY = Number(bounds.y) || drag.currentWindowY;
          drag.startWindowX = drag.currentWindowX;
          drag.startWindowY = drag.currentWindowY;
        }).catch(() => {});
      }

      function handlePointerMove(event) {
        if (!drag.pointerDown || event.pointerId !== drag.pointerId) return;

        const deltaX = event.screenX - drag.startScreenX;
        const deltaY = event.screenY - drag.startScreenY;

        if (!drag.dragging && Math.abs(deltaX) + Math.abs(deltaY) >= 3) {
          drag.dragging = true;
          shell.classList.add('dragging');
        }

        if (!drag.dragging) return;

        queueWindowMove(
          Math.round(drag.startWindowX + deltaX),
          Math.round(drag.startWindowY + deltaY)
        );
      }

      function handlePointerEnd(event) {
        if (!drag.pointerDown || event.pointerId !== drag.pointerId) return;

        if (drag.dragging) {
          drag.suppressClickUntil = Date.now() + 120;
          event.preventDefault();
        }

        drag.pointerDown = false;
        drag.dragging = false;
        shell.classList.remove('dragging');
      }

      function fileToDataUrl(file) {
        return new Promise((resolve) => {
          const reader = new FileReader();
          reader.onload = () => resolve(typeof reader.result === 'string' ? reader.result : '');
          reader.onerror = () => resolve('');
          reader.readAsDataURL(file);
        });
      }

      async function consumeFiles(fileList) {
        const files = Array.from(fileList || []);
        if (files.length === 0) return;

        const filePayload = files
          .map((file) => ({
            name: file.name || 'file',
            path: typeof file.path === 'string' ? file.path : '',
            isFile: true,
          }))
          .filter((file) => !!file.path);

        if (filePayload.length > 0) {
          setAttachment({ kind: 'files', files: filePayload });
          return;
        }

        if (files.length === 1 && String(files[0].type || '').startsWith('image/')) {
          const dataUrl = await fileToDataUrl(files[0]);
          if (dataUrl) {
            setAttachment({
              kind: 'img',
              dataUrl,
              name: files[0].name || 'clipboard-image.png',
            });
          }
        }
      }

      async function refreshPrompts() {
        try {
          const prompts = await launcherApi.getPrompts();
          state.prompts = Array.isArray(prompts) ? prompts : [];
          state.selectedIndex = 0;
          applyFilter();
        } catch (_error) {
          state.prompts = [];
          state.filtered = [];
          state.selectedIndex = -1;
          renderList();
        }
      }

      async function resetAndRefresh() {
        queryInput.value = '';
        clearAttachment();
        await refreshPrompts();
        await syncWindowBounds();
        queryInput.focus();
        queryInput.select();
      }

      queryInput.addEventListener('input', () => {
        applyFilter();
      });

      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          event.preventDefault();
          if (state.attachment) {
            clearAttachment();
            return;
          }
          launcherApi.close();
          return;
        }

        if (event.key === 'ArrowDown') {
          event.preventDefault();
          shiftSelection(1);
          return;
        }

        if (event.key === 'ArrowUp') {
          event.preventDefault();
          shiftSelection(-1);
          return;
        }

        if (event.key === 'Enter') {
          event.preventDefault();
          if (!state.showResults) return;
          const useTextPayload = !(event.ctrlKey || event.metaKey);
          executeCurrent(useTextPayload);
        }
      });

      document.addEventListener('pointerdown', handlePointerDown, true);
      document.addEventListener('pointermove', handlePointerMove, true);
      document.addEventListener('pointerup', handlePointerEnd, true);
      document.addEventListener('pointercancel', handlePointerEnd, true);

      document.addEventListener('click', (event) => {
        if (Date.now() < drag.suppressClickUntil) {
          event.preventDefault();
          event.stopPropagation();
        }
      }, true);

      window.addEventListener('drop', async (event) => {
        event.preventDefault();
        await consumeFiles(event.dataTransfer?.files);
      });

      window.addEventListener('dragover', (event) => {
        event.preventDefault();
      });

      window.addEventListener('paste', async (event) => {
        const clipboardFiles = event.clipboardData?.files;
        if (clipboardFiles && clipboardFiles.length > 0) {
          event.preventDefault();
          await consumeFiles(clipboardFiles);
          return;
        }

        const imageData = launcherApi.readClipboardImage();
        if (imageData) {
          event.preventDefault();
          setAttachment({
            kind: 'img',
            dataUrl: imageData,
            name: 'clipboard-image.png',
          });
        }
      });

      launcherApi.onRefresh(() => {
        resetAndRefresh();
      });

      launcherApi.onFocusInput(() => {
        queryInput.focus();
      });

      updateInputPlaceholder();
      resetAndRefresh();
    })();
  </script>
</body>
</html>
